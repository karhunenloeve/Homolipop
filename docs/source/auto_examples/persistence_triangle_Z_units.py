"""
Example script: persistent homology over :math:`\\mathbb Z` using only unit pivots.

This file demonstrates :func:`homolipop.persistence.persistent_homology_unit_ring`
with coefficient ring :math:`\\mathbb Z`, under the restriction that matrix reduction
is allowed to pivot only on units of the ring.

The restriction to unit pivots is a standard way to adapt the usual persistence reduction
to rings that are not fields. Over :math:`\\mathbb Z`, the only units are :math:`\\pm 1`.
In this example, all nonzero boundary coefficients are :math:`\\pm 1`, so the reduction
behaves as over a field, and the pairing agrees with field coefficients.

Mathematical conventions
========================

Filtered simplicial complex
---------------------------

Let :math:`K` be the abstract simplicial complex generated by the 2-simplex
:math:`(0,1,2)`. Let

.. math::

   \\sigma_0,\\sigma_1,\\dots,\\sigma_{m-1}

be the list ``simplices`` returned by :func:`homolipop.simplices.build_complex`,
assumed to satisfy the filtration admissibility condition

.. math::

   \\tau \\subseteq \\sigma_j \\implies \\tau = \\sigma_i \\text{ for some } i \\le j.

For each index :math:`i`, let :math:`K_i` be the subcomplex generated by
:math:`\\{\\sigma_0,\\dots,\\sigma_i\\}`.

Coefficients and units
----------------------

The coefficient ring is

.. math::

   R = \\mathbb Z.

Its group of units is

.. math::

   R^\\times = \\{+1,-1\\}.

Unit-pivot reduction
--------------------

Let :math:`\\partial_k : C_k(K;R) \\to C_{k-1}(K;R)` be the simplicial boundary map.
When computing persistence via boundary matrix reduction over a general ring,
division by a pivot is not always possible. The unit-pivot algorithm restricts pivots
to units of the ring, so division is always permitted.

Over :math:`\\mathbb Z`, this means pivots must be :math:`\\pm 1`.

In the simplicial boundary of an abstract simplicial complex with the standard orientation,
every nonzero boundary coefficient is :math:`\\pm 1`. Therefore, for this example,
every pivot that occurs in the usual reduction is a unit pivot, and the unit-pivot algorithm
computes the same pairing as the field-based algorithm.

Persistent pairing format
-------------------------

The routine :func:`homolipop.persistence.persistent_homology_unit_ring` is assumed to return

- ``pairs`` as triples ``(birth, death, dim)``
- ``unpaired`` as pairs ``(birth, dim)``

with the standard persistence interpretation in the filtration order of ``simplices``.

Expected qualitative outcome
----------------------------

For a filled triangle, the persistence behaviour is as follows.

- One connected component in dimension 0 is born at the first vertex and remains unpaired.
- A 1-cycle is created when the last edge closing the boundary appears and dies when the
  2-simplex appears.

The exact indices depend on the simplex ordering returned by :func:`build_complex`.

Implementation contract
-----------------------

This script assumes that :func:`ring_Z_units()` returns a ring descriptor for :math:`\\mathbb Z`
together with the ability to test whether an element is a unit and to divide by units.
"""

from __future__ import annotations

from homolipop.persistence import persistent_homology_unit_ring, ring_Z_units
from homolipop.simplices import build_complex


def main() -> None:
    """
    Compute persistent homology over :math:`\\mathbb Z` using unit-pivot reduction.

    The script prints

    - all paired events as ``(birth, death, dim)``
    - all unpaired events as ``(birth, dim)``
    """
    simplices = build_complex([(0, 1, 2)], max_dim=2).all_simplices
    result = persistent_homology_unit_ring(simplices, ring=ring_Z_units())

    print("Pairs (birth, death, dim) over Z with unit pivots:")
    for pair in result.pairs:
        print(pair)

    print("Unpaired (birth, dim):")
    for u in result.unpaired:
        print(u)


if __name__ == "__main__":
    main()