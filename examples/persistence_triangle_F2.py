"""
Example script: persistent homology over a finite field on a small filtered complex.

This file demonstrates :func:`homolipop.persistence.persistent_homology_field`
on the simplicial complex generated by a single triangle.

The filtration used here is the order of the list ``simplices`` returned by
:func:`homolipop.simplices.build_complex`. This order is assumed to be compatible
with the face relation, meaning every face appears no later than the simplex itself.

Mathematical conventions
========================

Filtered simplicial complex
---------------------------

Let :math:`K` be an abstract simplicial complex on a finite vertex set.
A filtration of :math:`K` is a nested sequence of subcomplexes

.. math::

   \\emptyset = K_{-1} \\subseteq K_0 \\subseteq \\cdots \\subseteq K_{m-1} = K,

such that each step adds exactly one simplex.
Equivalently, a filtration is given by an ordering of the simplices

.. math::

   \\sigma_0,\\sigma_1,\\dots,\\sigma_{m-1},

with the admissibility condition

.. math::

   \\tau \\subseteq \\sigma_j \\implies \\tau = \\sigma_i \\text{ for some } i \\le j.

In this file, the filtration order is the order of the list ``simplices``.

Coefficients
------------

Fix a prime :math:`p` and let :math:`\\mathbb F_p` be the finite field of order :math:`p`.
All homology groups below are taken with coefficients in :math:`\\mathbb F_p`.

Persistent homology in this setting
-----------------------------------

Let :math:`K_i` denote the subcomplex generated by :math:`\\{\\sigma_0,\\dots,\\sigma_i\\}`.
For each dimension :math:`k \\ge 0`, we obtain a persistence module

.. math::

   H_k(K_0;\\mathbb F_p)
   \\to
   H_k(K_1;\\mathbb F_p)
   \\to \\cdots \\to
   H_k(K_{m-1};\\mathbb F_p),

induced by inclusions :math:`K_i \\hookrightarrow K_j`.

Pairing output format
---------------------

The algorithm implemented by :func:`homolipop.persistence.persistent_homology_field`
is assumed to compute the standard simplex pairing produced by matrix reduction.

- A *paired* class is reported as a triple ``(birth, death, dim)``, meaning that a
  homology class in dimension ``dim`` is born when simplex ``simplices[birth]`` is added
  and dies when simplex ``simplices[death]`` is added.

- An *unpaired* class is reported as a pair ``(birth, dim)``, meaning that the class born
  at index ``birth`` in dimension ``dim`` persists to the end of the filtration.

In this file the complex is a single filled triangle, so there is one connected component
born at the first vertex that remains unpaired, and the 1-cycle created by the last edge
dies when the 2-simplex is added.

Implementation contract
-----------------------

This file assumes the following.

- The input ``simplices`` is a list of simplices represented as strictly increasing tuples.
- The list order is a filtration order satisfying the admissibility condition above.
- ``field_Fp(p)`` constructs a field descriptor implementing arithmetic in :math:`\\mathbb F_p`.
- The return value ``result`` has attributes ``pairs`` and ``unpaired`` as described above.
"""

from __future__ import annotations

import numpy as np

from homolipop.persistence import field_Fp, persistent_homology_field
from homolipop.simplices import build_complex


def main() -> None:
    """
    Compute persistent homology over :math:`\\mathbb F_2` for a single filled triangle.

    The simplicial complex is generated by the maximal simplex ``(0, 1, 2)``.
    The filtration is the simplex order returned by :func:`build_complex`, truncated to
    dimension at most 2.

    The script prints

    - the filtration simplices with indices
    - all paired events as ``(birth, death, dim)``
    - all unpaired events as ``(birth, dim)``
    """
    simplices = build_complex([(0, 1, 2)], max_dim=2).all_simplices
    result = persistent_homology_field(simplices, field=field_Fp(2))

    print("Filtration simplices:")
    for i, s in enumerate(simplices):
        print(i, s)

    print("\nPairs (birth, death, dim):")
    for pair in result.pairs:
        print(pair)

    print("\nUnpaired (birth, dim):")
    for u in result.unpaired:
        print(u)


if __name__ == "__main__":
    main()