from __future__ import annotations

from dataclasses import dataclass
from itertools import combinations
from typing import Dict, Iterable, Iterator, List, Sequence, Tuple

Simplex = Tuple[int, ...]


@dataclass(frozen=True)
class SimplicialComplex:
    """
    Explicit simplicial complex generated by maximal simplices.

    Invariants
    - Each simplex is a strictly increasing tuple of ints.
    - simplices_by_dim[k] is sorted lexicographically.
    - all_simplices concatenates simplices_by_dim in increasing dimension order.
    - index maps each simplex to its position in all_simplices.
    """
    simplices_by_dim: Dict[int, List[Simplex]]
    all_simplices: List[Simplex]
    index: Dict[Simplex, int]


def simplex_dim(simplex: Simplex) -> int:
    return len(simplex) - 1


def normalize_simplex(vertices: Iterable[int]) -> Simplex:
    """
    Canonical simplex representation as a strictly increasing tuple.

    Runtime
    - Sorting dominates: O(m log m) where m is the number of given vertices.
    - For Delaunay facets, m is small and fixed, so this is constant time in practice.
    """
    return tuple(sorted(set(int(v) for v in vertices)))


def iter_faces(simplex: Simplex, *, face_dim: int) -> Iterator[Simplex]:
    """
    Enumerate all faces of a fixed dimension.
    """
    face_size = face_dim + 1
    if face_size <= 0 or face_size > len(simplex):
        return
    yield from combinations(simplex, face_size)


def simplicial_closure(
    maximal_simplices: Sequence[Simplex],
    *,
    max_dim: int | None = None,
) -> set[Simplex]:
    """
    Compute the simplicial closure generated by maximal_simplices, optionally truncated at max_dim.

    Optimality
    - Any explicit construction is Omega(|K|) where |K| is the number of simplices produced.
    - This routine is Theta(total_number_of_generated_faces) up to hashing constants.
    """
    closure: set[Simplex] = set()

    for simplex in maximal_simplices:
        s = normalize_simplex(simplex)
        d = simplex_dim(s)
        d_cap = d if max_dim is None else min(d, max_dim)

        for k in range(d_cap, -1, -1):
            closure.update(iter_faces(s, face_dim=k))

    return closure


def group_by_dimension(simplices: Iterable[Simplex]) -> Dict[int, List[Simplex]]:
    """
    Group simplices by dimension and sort each group lexicographically.
    """
    by_dim: Dict[int, List[Simplex]] = {}

    for s in simplices:
        if not s:
            continue
        by_dim.setdefault(simplex_dim(s), []).append(s)

    for dim in by_dim:
        by_dim[dim].sort()

    return dict(sorted(by_dim.items(), key=lambda item: item[0]))


def build_complex(
    maximal_simplices: Sequence[Simplex],
    *,
    max_dim: int | None = None,
) -> SimplicialComplex:
    """
    Build an explicit simplicial complex from maximal simplices.

    Output order
    - all_simplices lists simplices dimension by dimension, each group sorted lexicographically.
    - index provides O(1) expected lookup from simplex to its global position.

    Optimality
    - After closure computation, sorting dominates at O(|K| log |K|) comparisons in general,
      which is unavoidable for producing deterministic ordered lists.
    """
    closure = simplicial_closure(maximal_simplices, max_dim=max_dim)
    simplices_by_dim = group_by_dimension(closure)

    all_simplices: List[Simplex] = []
    for dim in simplices_by_dim:
        all_simplices.extend(simplices_by_dim[dim])

    index = {s: i for i, s in enumerate(all_simplices)}
    return SimplicialComplex(simplices_by_dim=simplices_by_dim, all_simplices=all_simplices, index=index)