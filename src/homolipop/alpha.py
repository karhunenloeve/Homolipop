from __future__ import annotations

from dataclasses import dataclass
from itertools import combinations
from typing import Dict, Sequence

import numpy as np

from .simplices import Simplex, build_complex, simplex_dim


@dataclass(frozen=True)
class AlphaFiltration:
    r"""
    Alpha filtration values for simplices, stored as squared radii.

    Mathematical specification
    ==========================

    Let :math:`P = \{p_0,\dots,p_{n-1}\} \subset \mathbb{R}^d` be a finite set of points.
    Let :math:`K` be a simplicial complex on vertex set :math:`\{0,\dots,n-1\}`.

    An *alpha filtration value* is a function

    .. math::

        f : K \to \mathbb{R}_{\ge 0}

    such that

    .. math::

        \tau \subseteq \sigma \implies f(\tau) \le f(\sigma).

    In many constructions, :math:`f(\sigma)` is defined as the squared radius of a
    circumsphere associated to the simplex :math:`\sigma`. This class stores the
    mapping :math:`\sigma \mapsto f(\sigma)` in the attribute ``alpha_sq``.

    Data model
    ==========
    ``alpha_sq`` is a dictionary mapping each simplex to its filtration value,
    expressed as a nonnegative float representing a squared Euclidean radius.

    Notes
    =====
    - Squared radii avoid square roots and are numerically more stable.
    - Correctness of persistent homology pipelines typically assumes the
      monotonicity property above. This container does not enforce it but is
      intended to store an already-monotone assignment.
    """

    alpha_sq: Dict[Simplex, float]


def alpha_values_squared(
    points: np.ndarray,
    delaunay_simplices: Sequence[Simplex],
    *,
    max_dim: int,
) -> AlphaFiltration:
    r"""
    Compute monotone alpha filtration values for all simplices up to a given dimension.

    Mathematical problem
    ====================

    Input:
    - point coordinates ``points`` as an array of shape :math:`(n,d)`
    - a list of simplices ``delaunay_simplices`` on vertex set :math:`\{0,\dots,n-1\}`
      that generate a complex, typically a Delaunay complex
    - an integer ``max_dim``

    Output:
    - an :class:`AlphaFiltration` mapping each simplex :math:`\sigma` of dimension
      at most ``max_dim`` in the generated complex to a nonnegative value
      :math:`f(\sigma)`.

    Construction
    ============
    1. Build the simplicial complex :math:`K` generated by ``delaunay_simplices``
       and then restrict to all simplices of dimension :math:`\le` ``max_dim``.
    2. For each simplex :math:`\sigma = [v_0,\dots,v_k]` with :math:`k \ge 1`,
       compute the squared radius :math:`r(\sigma)^2` of the circumsphere of the
       embedded points :math:`(p_{v_i})_{i=0}^k`.
       For vertices and the empty simplex, assign value :math:`0`.
    3. Enforce filtration monotonicity by propagating values from cofaces to faces:

       .. math::

           f(\tau) \leftarrow \min\bigl(f(\tau), f(\sigma)\bigr)
           \quad \text{for all } \tau \subset \sigma.

       This guarantees

       .. math::

           \tau \subseteq \sigma \implies f(\tau) \le f(\sigma).

    Algorithmic details
    ===================
    - The circumsphere radius is computed by :func:`circumsphere_radius_squared`
      via a least squares solve on a Gram system. Degenerate simplices with
      affinely dependent vertices raise ``ValueError``.
    - The monotonicity enforcement iterates dimensions from ``max_dim`` down to 1
      and pushes each simplex value down to its codimension-1 faces. Repeating by
      descending dimension ensures all lower-dimensional faces are updated.

    Parameters
    ==========
    points:
        Array of shape ``(number_of_points, ambient_dimension)`` containing point
        coordinates in :math:`\mathbb{R}^d`.
    delaunay_simplices:
        Sequence of simplices, each represented by vertex indices, typically
        maximal simplices from a Delaunay triangulation.
    max_dim:
        Maximum simplex dimension to include in the output.

    Returns
    =======
    AlphaFiltration
        Object containing the dictionary ``alpha_sq`` mapping simplices to squared
        filtration values.

    Raises
    ======
    ValueError
        If ``points`` is not a 2D array, if ``max_dim`` is out of range, or if any
        simplex is geometrically degenerate for circumsphere computation.
    """
    point_array = np.asarray(points, dtype=float)
    if point_array.ndim != 2:
        raise ValueError("points must have shape (number_of_points, ambient_dimension)")

    ambient_dim = point_array.shape[1]
    if max_dim < 0 or max_dim > ambient_dim:
        raise ValueError("max_dim must satisfy 0 <= max_dim <= ambient_dimension")

    complex_data = build_complex(delaunay_simplices, max_dim=max_dim)
    all_simplices = complex_data.all_simplices

    alpha_sq: Dict[Simplex, float] = {}

    # Step 1: assign a preliminary value to each simplex based on circumsphere radius.
    #
    # Convention:
    # - for dim <= 0, assign 0.0
    # - for dim >= 1, assign circumsphere radius squared
    #
    # This produces a value that is geometrically meaningful but not necessarily
    # monotone with respect to face inclusion, hence the next step.
    for simplex in all_simplices:
        d = simplex_dim(simplex)
        if d <= 0:
            alpha_sq[simplex] = 0.0
            continue

        vertex_points = point_array[np.array(simplex, dtype=int)]
        radius_sq = circumsphere_radius_squared(vertex_points)
        alpha_sq[simplex] = float(radius_sq)

    # Step 2: enforce monotonicity by pushing coface values down to their faces.
    #
    # For each simplex sigma of dimension dim, update every face tau of dimension dim-1:
    #   f(tau) = min(f(tau), f(sigma)).
    #
    # Iterating dim from max_dim down to 1 ensures that information propagates all the
    # way down to vertices through repeated updates.
    for dim in range(max_dim, 0, -1):
        for simplex in complex_data.simplices_by_dim.get(dim, []):
            value = alpha_sq[simplex]
            for face in combinations(simplex, dim):
                if alpha_sq[face] > value:
                    alpha_sq[face] = value

    return AlphaFiltration(alpha_sq=alpha_sq)


def circumsphere_radius_squared(vertex_points: np.ndarray) -> float:
    r"""
    Compute the squared radius of the circumsphere of a simplex given its vertex coordinates.

    Mathematical specification
    ==========================

    Let :math:`v_0,\dots,v_{k-1} \in \mathbb{R}^d` be the vertices of a
    :math:`(k-1)`-simplex. A *circumcenter* is a point :math:`c \in \mathbb{R}^d`
    such that

    .. math::

        \|c - v_0\|^2 = \|c - v_i\|^2 \quad \text{for all } i = 1,\dots,k-1.

    If the vertices are affinely independent, the circumcenter exists and is unique
    in the affine span of the vertices, and the *circumsphere radius* is

    .. math::

        r^2 = \|c - v_0\|^2.

    Linear algebra derivation used here
    ===================================

    Write :math:`p_0 = v_0` and :math:`d_i = v_i - p_0` for :math:`i=1,\dots,k-1`,
    and collect the row vectors in a matrix :math:`D \in \mathbb{R}^{(k-1)\times d}`.

    Seek the circumcenter in the affine span in the form

    .. math::

        c = p_0 + D^\top x

    for some :math:`x \in \mathbb{R}^{k-1}`. The equal-distance equations are
    equivalent to the Gram system

    .. math::

        (D D^\top) x = \tfrac{1}{2} b,

    where :math:`b_i = \|d_i\|^2`. Here :math:`G = D D^\top` is the Gram matrix.

    - If the vertices are affinely independent, :math:`G` is invertible and the
      solution is unique.
    - If they are affinely dependent, :math:`G` is singular and the simplex is
      degenerate. This function raises ``ValueError`` in that case.

    Numerics
    ========
    The implementation solves the linear system using ``numpy.linalg.lstsq`` and
    checks the returned rank. For nondegenerate input, the least squares solution
    coincides with the exact solution.

    Parameters
    ==========
    vertex_points:
        Array of shape ``(k, ambient_dimension)``, where ``k`` is the number of
        vertices of the simplex.

    Returns
    =======
    float
        The squared radius :math:`r^2` as a nonnegative float.

    Raises
    ======
    ValueError
        If the input does not have shape ``(k,d)``, or if the vertices are affinely
        dependent.
    """
    if vertex_points.ndim != 2:
        raise ValueError("vertex_points must be a 2D array of shape (k, ambient_dimension)")

    k, ambient_dim = vertex_points.shape
    if k <= 1:
        return 0.0

    # Choose p0 as base point and express all other vertices relative to p0.
    p0 = vertex_points[0]
    diffs = vertex_points[1:] - p0  # shape: (k-1, ambient_dim)

    # Gram matrix G = D D^T, where D = diffs.
    gram = diffs @ diffs.T  # shape: (k-1, k-1)

    # Right-hand side: (1/2) * ||d_i||^2 for each row d_i of diffs.
    rhs = 0.5 * np.einsum("ij,ij->i", diffs, diffs)  # shape: (k-1,)

    # Solve G x = rhs in a least squares sense; for full rank, this is the unique solution.
    center_coords, residuals, rank, _ = np.linalg.lstsq(gram, rhs, rcond=None)

    # Full affine independence corresponds to rank k-1.
    if rank < k - 1:
        raise ValueError("degenerate simplex: affinely dependent vertices")

    # Recover circumcenter c = p0 + D^T x.
    center = p0 + diffs.T @ center_coords

    # Squared radius r^2 = ||c - p0||^2.
    radius_sq = float(np.dot(center - p0, center - p0))

    # Guard against tiny negative values from floating point round-off.
    if radius_sq < 0.0:
        radius_sq = 0.0

    return radius_sq