from __future__ import annotations

from dataclasses import dataclass
from typing import Callable, Dict, Iterable, List, Sequence, Tuple, TypeVar

from .simplices import Simplex, simplex_dim

R = TypeVar("R")
SparseColumn = Dict[int, R]


@dataclass(frozen=True)
class RingOps:
    r"""
    Ring interface for coefficient arithmetic.

    The coboundary construction needs only the following operations on coefficients:

    - a distinguished unit ``one`` representing :math:`1`
    - addition ``add`` representing :math:`+`
    - additive inverse ``neg`` representing :math:`x \mapsto -x`
    - a zero test ``is_zero``

    No multiplication is required here, since the coboundary matrix entries for
    simplicial cochains are signs :math:`\pm 1` and are accumulated by addition.

    The intended algebraic laws are those of an additive commutative group with a
    distinguished element ``one`` and a compatible negation:

    .. math::

        \mathrm{add}(a,b) = a+b,\quad \mathrm{neg}(a) = -a,\quad
        \mathrm{add}(a,\mathrm{neg}(a)) = 0.

    Correctness relies on these operations being consistent with each other.
    """

    one: R
    add: Callable[[R, R], R]
    neg: Callable[[R], R]
    is_zero: Callable[[R], bool]


@dataclass(frozen=True)
class Coboundary:
    r"""
    Sparse coboundary operator in filtration order.

    Let ``simplices`` be a list of simplices ordered by a filtration. For each
    dimension ``k`` there is a cochain group :math:`C^k` freely generated by the
    ``k``-simplices. The simplicial coboundary

    .. math::

        \delta^k : C^k \to C^{k+1}

    is determined on basis cochains by

    .. math::

        \delta^k(\sigma^\*) = \sum_{\tau \supset \sigma,\ \dim\tau=k+1}
        [\tau:\sigma]\ \tau^\*,

    where :math:`[\tau:\sigma] \in \{\pm 1\}` is the incidence number induced by
    the vertex order of ``tau`` and the usual alternating-sign convention.

    Storage model
    -------------
    ``columns[k][i]`` is a sparse column for :math:`\delta^{k}` corresponding to
    the ``i``-th ``k``-simplex when restricted to the dimension-``k`` subsequence.
    The keys of a column are *global indices* of :math:`(k+1)`-simplices in the
    filtration list. Values are coefficients in the chosen ring.

    Concretely, an entry

    .. math::

        \texttt{columns[k][i][j]} = a

    represents that the basis element indexed by the global simplex ``simplices[j]``
    appears in :math:`\delta^{k}` applied to the local ``k``-simplex with coefficient
    :math:`a`.

    Attributes
    ----------
    simplices:
        All simplices in filtration order.
    index:
        Map ``simplex ↦ global_index`` into ``simplices``.
    columns:
        Nested list by dimension. ``columns[k]`` has length equal to the number of
        ``k``-simplices. Each entry is a sparse column mapping global indices of
        ``(k+1)``-simplices to coefficients.
    """

    simplices: List[Simplex]
    index: Dict[Simplex, int]
    columns: List[List[SparseColumn]]


def build_coboundary(
    simplices_in_filtration_order: Sequence[Simplex],
    *,
    ring: RingOps[R],
) -> Coboundary:
    r"""
    Build the simplicial coboundary operator as sparse columns.

    Input
    -----
    ``simplices_in_filtration_order`` is assumed to list a simplicial complex
    closed under faces, ordered by a filtration.
    The coboundary is built using the standard oriented incidence coefficients
    :math:`[\tau:\sigma] \in \{\pm 1\}` for codimension-1 faces.

    Output
    ------
    Returns a :class:`Coboundary` whose ``columns`` encode :math:`\delta^k` for all
    ``k`` present in the input.

    Construction, minimal
    ---------------------
    1. Index all simplices globally by filtration position.
    2. Group global indices by dimension ``k``.
    3. For each ``(k+1)``-simplex ``τ`` and each oriented codimension-1 face
       ``σ ⊂ τ``, insert the coefficient :math:`[\tau:\sigma]` into the column of
       ``σ`` at row ``τ``.
       If the same row is encountered multiple times, coefficients are added and
       removed if they cancel to zero.

    The cancellation step is essential over rings where :math:`1 + (-1) = 0`
    and for robustness if the input contains duplicates or if multiple passes
    were to be composed.

    Raises
    ------
    None explicitly, but assumes that ring operations are total and that simplices
    are hashable.
    """
    simplices = list(simplices_in_filtration_order)
    if not simplices:
        return Coboundary(simplices=[], index={}, columns=[])

    index: Dict[Simplex, int] = {s: i for i, s in enumerate(simplices)}
    max_dim = max(simplex_dim(s) for s in simplices)

    by_dim_global: List[List[int]] = [[] for _ in range(max_dim + 1)]
    for global_i, s in enumerate(simplices):
        d = simplex_dim(s)
        if d >= 0:
            by_dim_global[d].append(global_i)

    global_to_local: List[int] = [-1] * len(simplices)
    for k in range(max_dim + 1):
        for local_i, global_i in enumerate(by_dim_global[k]):
            global_to_local[global_i] = local_i

    columns: List[List[SparseColumn]] = [
        [dict() for _ in range(len(by_dim_global[k]))] for k in range(max_dim + 1)
    ]

    one, add, neg, is_zero = ring.one, ring.add, ring.neg, ring.is_zero

    for k_plus_1 in range(1, max_dim + 1):
        for global_tau in by_dim_global[k_plus_1]:
            tau = simplices[global_tau]

            for coeff, sigma in oriented_codim1_faces(tau, one=one, neg=neg):
                global_sigma = index.get(sigma)
                if global_sigma is None:
                    continue

                local_sigma = global_to_local[global_sigma]
                col = columns[k_plus_1 - 1][local_sigma]

                previous = col.get(global_tau)
                if previous is None:
                    col[global_tau] = coeff
                    continue

                updated = add(previous, coeff)
                if is_zero(updated):
                    del col[global_tau]
                else:
                    col[global_tau] = updated

    return Coboundary(simplices=simplices, index=index, columns=columns)


def oriented_codim1_faces(
    simplex: Simplex,
    *,
    one: R,
    neg: Callable[[R], R],
) -> Iterable[Tuple[R, Simplex]]:
    r"""
    Enumerate oriented codimension-1 faces with incidence signs.

    Let ``simplex = (v_0, …, v_{n-1})`` be an ordered simplex.
    For each ``i`` define the face obtained by deleting the ``i``-th vertex

    .. math::

        \sigma_i = (v_0,\dots,\widehat{v_i},\dots,v_{n-1}).

    The standard simplicial sign convention gives the incidence coefficient

    .. math::

        [ (v_0,\dots,v_{n-1}) : \sigma_i ] = (-1)^i.

    This generator yields pairs ``(coeff, face)``, where ``coeff`` is ``one`` for
    even ``i`` and ``neg(one)`` for odd ``i``.

    Notes
    -----
    The convention matches the usual boundary formula

    .. math::

        \partial(v_0,\dots,v_{n-1})
        = \sum_{i=0}^{n-1} (-1)^i (v_0,\dots,\widehat{v_i},\dots,v_{n-1})

    and dualizes to coboundary on cochains.
    """
    n = len(simplex)
    for i in range(n):
        face = simplex[:i] + simplex[i + 1 :]
        coeff = one if (i % 2 == 0) else neg(one)
        yield coeff, face


def integer_ring() -> RingOps[int]:
    r"""
    Coefficients in the ring :math:`\mathbb{Z}`.

    Returns ring operations implementing

    .. math::

        1,\quad a+b,\quad -a,\quad a=0.

    This is the default coefficient structure for integral cohomology.
    """
    return RingOps(
        one=1,
        add=lambda a, b: a + b,
        neg=lambda a: -a,
        is_zero=lambda a: a == 0,
    )


def prime_field(p: int) -> RingOps[int]:
    r"""
    Coefficients in the prime field :math:`\mathbb{F}_p`.

    For a prime ``p``, the field is ``Z/pZ`` with operations

    .. math::

        a \oplus b = (a+b) \bmod p,
        \qquad
        \ominus a = (-a) \bmod p.

    This function does not test primality. It only enforces ``p ≥ 2`` and provides
    arithmetic modulo ``p``. If ``p`` is composite, the returned structure is a
    ring ``Z/pZ`` but not a field.

    Parameters
    ----------
    p:
        Modulus, must satisfy ``p ≥ 2``.

    Returns
    -------
    RingOps[int]
        Ring operations modulo ``p``.
    """
    if p < 2:
        raise ValueError("p must be >= 2")

    def add_mod(a: int, b: int) -> int:
        return (a + b) % p

    def neg_mod(a: int) -> int:
        return (-a) % p

    def is_zero_mod(a: int) -> bool:
        return (a % p) == 0

    return RingOps(one=1 % p, add=add_mod, neg=neg_mod, is_zero=is_zero_mod)


def build_coboundary_Z(simplices_in_filtration_order: Sequence[Simplex]) -> Coboundary:
    r"""
    Convenience wrapper: coboundary over :math:`\mathbb{Z}`.
    """
    return build_coboundary(simplices_in_filtration_order, ring=integer_ring())


def build_coboundary_Fp(simplices_in_filtration_order: Sequence[Simplex], p: int) -> Coboundary:
    r"""
    Convenience wrapper: coboundary over :math:`\mathbb{Z}/p\mathbb{Z}`.
    """
    return build_coboundary(simplices_in_filtration_order, ring=prime_field(p))